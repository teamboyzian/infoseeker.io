// netlify/functions/ask.js
// Runtime: Node 18+ expected (global fetch available)
// Make sure to set OPENAI_API_KEY, GOOGLE_API_KEY, GOOGLE_CSE_ID in Netlify env vars

exports.handler = async function(event, context) {
  try {
    if (event.httpMethod !== 'POST') {
      return { statusCode: 405, body: 'Method Not Allowed' };
    }
    const body = JSON.parse(event.body || '{}');
    const question = (body.question || '').trim();
    if (!question) {
      return { statusCode: 400, body: JSON.stringify({ error: 'Question is required' }) };
    }

    const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
    const GOOGLE_CSE_ID = process.env.GOOGLE_CSE_ID;
    const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

    if (!GOOGLE_API_KEY || !GOOGLE_CSE_ID || !OPENAI_API_KEY) {
      return { statusCode: 500, body: JSON.stringify({ error: 'Missing environment variables' }) };
    }

    // 1) Call Google Custom Search API
    const q = encodeURIComponent(question);
    const googleUrl = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${GOOGLE_CSE_ID}&q=${q}&num=6`;
    const googleResp = await fetch(googleUrl);
    if (!googleResp.ok) {
      const t = await googleResp.text();
      return { statusCode: 502, body: JSON.stringify({ error: 'Google API error', details: t }) };
    }
    const googleJson = await googleResp.json();
    const items = googleJson.items || [];

    // prepare snippets and sources
    const topSnippets = [];
    const sources = [];
    for (const it of items) {
      const title = it.title || it.displayLink || it.link;
      const link = it.link;
      const snippet = it.snippet || '';
      if (link) {
        sources.push({ title, url: link });
      }
      if (snippet) {
        topSnippets.push({ title, link, snippet });
      }
    }

    // 2) Build prompt for OpenAI - instruct to use ONLY the provided snippets (Google) to answer
    let contextText = 'You are provided with the following search results pulled from Google Custom Search. Use ONLY these results to compose a concise, accurate answer to the user question. Do NOT invent facts beyond these results. If something is uncertain, say so and point the user to the sources.\n\n';
    topSnippets.forEach((s, i) => {
      contextText += `Result ${i+1} â€” Title: ${s.title}\nLink: ${s.link}\nSnippet: ${s.snippet}\n\n`;
    });
    contextText += `User question: ${question}\n\nNow produce:\n1) A short clear answer (2-6 paragraphs max) based only on the results above.\n2) After the answer, produce a short "Sources used" list that matches the provided links.\n3) If the results are insufficient, explicitly say the information is unclear and list the links for further reading.\n\nAnswer:\n`;

    // Call OpenAI Chat Completions
    const openaiResp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // you can change to a model you have access to
        messages: [
          { role: 'system', content: 'You are a helpful assistant that composes answers strictly based on provided web search snippets.' },
          { role: 'user', content: contextText }
        ],
        temperature: 0.1,
        max_tokens: 900
      })
    });

    if (!openaiResp.ok) {
      const t = await openaiResp.text();
      return { statusCode: 502, body: JSON.stringify({ error: 'OpenAI API error', details: t }) };
    }
    const openaiJson = await openaiResp.json();
    const aiMessage = openaiJson.choices && openaiJson.choices[0] && openaiJson.choices[0].message && openaiJson.choices[0].message.content;
    const answerText = aiMessage || 'No answer generated by AI.';

    // 3) Return combined answer + exact sources used (we return the Google links)
    return {
      statusCode: 200,
      body: JSON.stringify({
        answer: answerText,
        sources: sources.slice(0, 6)
      })
    };

  } catch (err) {
    console.error(err);
    return { statusCode: 500, body: JSON.stringify({ error: 'Internal server error', message: String(err) }) };
  }
};